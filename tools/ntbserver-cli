#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright GREYC - UMR 6072 ; Université de Caen Normandie
# Esplanade de la paix
# CS 14032
# 14032 Caen CEDEX 5
# contributeur : Pierre BLONDEAU, Davy GIGAN, Cyprien GOTTSTEIN (2014)
#
# Pierre BLONDEAU - pierre.blondeau@unicaen.fr
# Davy GIGAN - davy.gigan@unicaen.fr
# Cyprien GOTTSTEIN - gottstein.cyprien@gmail.com
#
# Ce logiciel est un programme informatique servant à déchiffrer un linux
# par le réseau et sans intervention de l'utilisateur.
#
# Ce logiciel est régi par la licence CeCILL-B soumise au droit français et
# respectant les principes de diffusion des logiciels libres. Vous pouvez
# utiliser, modifier et/ou redistribuer ce programme sous les conditions
# de la licence CeCILL-B telle que diffusée par le CEA, le CNRS et l'INRIA
# sur le site "http://www.cecill.info".
#
# En contrepartie de l'accessibilité au code source et des droits de copie,
# de modification et de redistribution accordés par cette licence, il n'est
# offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
# seule une responsabilité restreinte pèse sur l'auteur du programme,  le
# titulaire des droits patrimoniaux et les concédants successifs.
#
# A cet égard  l'attention de l'utilisateur est attirée sur les risques
# associés au chargement,  à l'utilisation,  à la modification et/ou au
# développement et à la reproduction du logiciel par l'utilisateur étant
# donné sa spécificité de logiciel libre, qui peut le rendre complexe à
# manipuler et qui le réserve donc à des développeurs et des professionnels
# avertis possédant  des  connaissances  informatiques approfondies.  Les
# utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
# logiciel à leurs besoins dans des conditions permettant d'assurer la
# sécurité de leurs systèmes et ou de leurs données et, plus généralement,
# à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
#
# Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
# pris connaissance de la licence CeCILL-B, et que vous en avez accepté les
# termes.
#
# ================================ English ================================
#
# Copyright GREYC - UMR 6072 ; Université de Caen Normandie
# Esplanade de la paix
# CS 14032
# 14032 Caen CEDEX 5
# contributor(s) : Pierre BLONDEAU, Davy GIGAN, Cyprien GOTTSTEIN (2014)
#
# Pierre BLONDEAU - pierre.blondeau@unicaen.fr
# Davy GIGAN - davy.gigan@unicaen.fr
# Cyprien GOTTSTEIN - gottstein.cyprien@gmail.com
#
# This software is a computer program whose purpose is to decrypt a linux
# by the network without user intervention.
#
# This software is governed by the CeCILL-B license under French law and
# abiding by the rules of distribution of free software.  You can  use,
# modify and/ or redistribute the software under the terms of the CeCILL-B
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info".
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and,  more generally, to use and operate it in the
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

# vim:set ai et sta ts=4 sts=4 sw=4 tw=160:
# Last modified: mardi 2015-08-11 16:43:20 +0200

import os, sys, json, csv
from argparse import ArgumentParser, FileType
import django
from Crypto.PublicKey import RSA

# Pour récupérer les objects django
sys.path.append("/usr/share/ntbserver")
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ntbserver.settings")
django.setup()
from ntbserver_api.models import *
from ntbserver_api.utils import *

verbose=False

def all_machines() :
    return Machine.objects.all()

def ids_machines(ids, error=True) :
    machines=Machine.objects.filter(machine_id__in=ids)
    ids_=ids[:]
    for m in machines:
        ids_.remove(m.machine_id)
    if error :
        for i in ids_ :
            print("Can't find id %s" %(i))
    return machines

def list_machines(machines, fields=["machine_id"], format='csv', output=None, skipColumnNames=False):
    res=[]
    machine_fields = dict(Machine._fields.items()).keys()
    for m in machines:
        if all (k in machine_fields for k in fields):
            extract={}
            for f in fields:
                extract[f]=m[f]
            res.append(extract)
        else:
             print("Fields error. Avaliable : %s" %(",".join(m_fields)))
    print_res(res, format, output, skipColumnNames )


def print_res(res, format='csv', output=None, skipColumnNames=False):
    if res and isinstance(res, list) and len(res) > 0 :
        columnNames=[]
        if format == 'csv':
            w = csv.DictWriter(output, res[0].keys(), delimiter=',')
            if not skipColumnNames :
                w.writeheader()
            for r in res :
                w.writerow(r)
        elif format == 'json' :
            json.dump(res, output)

def disable_machines(machines):
    for m in machines:
        m.disable()

def enable_machines(machines):
    for m in machines:
        m.enable()

def delete_machines(machines):
    for m in machines:
        m.delete()

def convert_machines(ids):
    machines=[]
    for i in ids :
        c = convert_uuid(i)
        m = ids_machines([i,c], False)
        if len(m) < 1:
            print("Can't find id %s or %s" %(i, c))
        elif len(m) > 1:
            print("Too many result for id %s or %s" %(i,c))
        else :
            machines.append(m[0])
    for m in machines:
        new_machine_id=convert_uuid(m.machine_id)
        print('%s -> %s' %(m.machine_id, new_machine_id))
        m.machine_id=new_machine_id
        m.save()

# Doit prendre des éléments en parametre pas de l'aleatoire
# def create_machine():
#     pk = RSA.generate(4096).publickey().exportKey('PEM')
#     m = Machine(machine_id="%s" %(uuid.uuid4()), public_key=pk , passphrase='')
#     m.generate_passphrase()
#     m.save()
def create_machine():
    print("To do !")

def main():
    parser = ArgumentParser(description="NTBServer CLI",add_help=True)
    parser.add_argument('-a','--all', action="store_true",help='All IDs')
    parser.add_argument('-i','--id', action="append",nargs='+',help='Machines IDs', default=[[]])
    parser.add_argument('-l', '--list', action='store_true',help='List machines')
    parser.add_argument('--fields', action='append',nargs='+',help='Field\'s filters ( default : machine_id )', default=[['machine_id']])
    parser.add_argument('--format', action='store',help='Output format ( default : csv )', choices=['csv','json'], default='csv')
    parser.add_argument('--output', action='store',help='Output file ( default : stdout )', type=FileType('wb', 0), default='-')
    parser.add_argument('-N', '--skip-column-names', action='store_true',help='Do not write column names in results.')
    parser.add_argument('-d', '--disable', action='store_true',help='Disable machines')
    parser.add_argument('-e', '--enable', action='store_true',help='Enable machines')
    parser.add_argument('--delete', action='store_true', help='Delete machines')
    parser.add_argument('--convert-uuid', action='store_true', help='Convert machines UUID from OLD or NEW')
    # parser.add_argument('-c', '--create', action='store_true',help='Create a new machine')
    # parser.add_argument('--public_key', action="store",help='Machine public key')
    # parser.add_argument('--passphrase', action="store",help='Machine passphrase')
    # parser.add_argument('-s', '--search', action='store_true', help='Search machines')
    # parser.add_argument('--ip', action='append', help='Search ID used by IPs')
    parser.add_argument('-v', '--verbose', action='store_true', help='Show more informations')

    args = parser.parse_args()

    # append + nargs='+' need union
    ids=[]
    ids.extend(reduce(set.union,map(set,args.id)))
    fields=[]
    fields.extend(reduce(set.union,map(set,args.fields)))

    if args.verbose :
        verbose=True

    machines=None
    if args.all :
        machines = all_machines()
    elif ids :
        error = False if args.convert_uuid else True
        machines = ids_machines(ids,error)

    if machines and args.list :
        list_machines(machines, fields=fields, format=args.format, output=args.output ,skipColumnNames=args.skip_column_names)
    elif machines and args.disable :
        disable_machines(machines)
    elif machines and args.enable :
        enable_machines(machines)
    elif machines and args.delete :
        delete_machines(machines)
    elif args.convert_uuid:
        convert_machines(ids)
    # elif args.create :
    #     create_machine()
    else :
        parser.print_help()

# Execution si je n'ai pas été chargé par un autre programme
if __name__ == "__main__":
    main()
